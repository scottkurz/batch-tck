= Jakarta Batch TCK Reference Guide
:toc:
:sectnums:

== Preface

This guide describes how to download, install, configure, and run the Technology Compatibility Kit (TCK) used to verify the compatibility of an implementation of the Jakarta Batch specification.

=== Licensing
The Jakarta Batch TCK is provided under the 
*Eclipse Foundation Technology Compatibility Kit License - v 1.0* [https://www.eclipse.org/legal/tck.php].

=== Who Should Use This Guide
This guide is for implementers of the Jakarta Batch specification, to assist in running the test suite that verifies the compatibility of their implementation.

=== Before You Read This Guide
Before reading this guide, you should familiarize yourself with the Jakarta Batch specification.

Information about the specification, including links to the specification documents, can be found on the Jakarta Batch project home page [https://projects.eclipse.org/projects/ee4j.batch] and also at the GitHub repository home  [https://github.com/eclipse-ee4j/batch-api].

== Introduction
The Jakarta Batch TCK tests implementations of the Jakarta Batch specification, which describes the job specification language, Java programming model, and runtime environment for Jakarta Batch applications.

=== What Tests Do I Need To Pass (to pass the TCK)?  

As an overview, note in order to pass the Jakarta Batch TCK you must run against your implementation, passing 100% of both the:

•	Signature Tests
•	TestNG Test Suite

The two types of tests are not encapsulated in a single execution task or command; they must be executed separately from each other and each must be executed separately for each version of Java tested (e.g. Java 8, etc.). 

== TCK Challenges/Appeals Process
The *Jakarta EE TCK Process 1.0* will govern all process details used for challenges to the Jakarta Batch TCK.    

Except from the *Jakarta EE TCK Process 1.0*:

> Specifications are the sole source of truth and considered overruling to the TCK in all senses. In the course of implementing a specification and attempting to pass the TCK, implementations may come to the conclusion that one or more tests or assertions do not conform to the specification and therefore MUST be excluded from the certification requirements.
> 
> Requests for tests to be excluded are referred to as Challenges.  This section identifies who can make challenges to the TCK, what challenges to the TCK may be submitted, how these challenges are submitted, how and to whom challenges are addressed.

Here is a https://docs.google.com/document/d/1Et3LtK-2SUuAoOV56t8R8fKnRWhbWqg9SLgm-VhbDPY/edit#heading=h.m0w944vn2kbp[link] to the [underline]#Challenges# section within the *Jakarta EE TCK Process 1.0*.

== Certification of Compatibility
The *Jakarta EE TCK Process 1.0* will define the core process details used to certify compatibility with the Jakarta Batch specification, through execution of the Jakarta Batch TCK.   

Except from the *Jakarta EE TCK Process 1.0*:

> Jakarta EE is a self-certification ecosystem. If you wish to have your implementation listed on the official https://jakarta.ee implementations page for the given specification, a certification request as defined in this section is required.

Here is a https://docs.google.com/document/d/1Et3LtK-2SUuAoOV56t8R8fKnRWhbWqg9SLgm-VhbDPY/edit#heading=h.jancgi3rd7xs[link] to the [underline]#Certification of Compatibility# section within the *Jakarta EE TCK Process 1.0*.

== Note on TCK guide format

The Jakarta Batch TCK evolved out of the earlier JSR 352 TCK (for more detail see https://www.jcp.org/en/jsr/detail?id=352[JSR 352: Batch Applications for the Java Platform]) and most likely will continue to evolve.   

While there are details in the previous JSR 352 TCK reference guide that could possibly be helpful to someone having difficulty or trying to understand some aspect of the TCK project, we have not yet "ported" all this information into this new guide.

Rather, we include the previous JSR 352 TCK reference guide in case it is of use.

Please use the https://projects.eclipse.org/projects/ee4j.batch/contact[contact] info for the Jakarta Batch project or open an issue on the TCK repo [https://github.com/eclipse-ee4j/batch-tck]
if there are issues with the documentation.

==	Installation

This section explains how to obtain the TCK and provides recommendations for how to install/extract it on your system.

===	Obtaining the Software

The Jakarta Batch TCK is distributed as a zip file, which contains the TCK artifacts (the test suite binary and source, porting package SPI binary and source, the test suite descriptor) in
 `/artifacts`, the TCK library dependencies in `/lib` and documentation in `/doc`.  You can  download the current source code from the Git repository: https://github.com/eclipse-ee4j/batch-tck.

===	The TCK Environment
The software can simply be extracted from the ZIP file. Once the TCK is extracted, you'll see the following structure:

 com.ibm.jbatch.tck-1.0.2/
     artifacts/ 
     doc/
     lib/ 
     build.xml
     batch-tck.properties 
     LICENSE.txt
     NOTICE.txt
     README.txt

In more detail:

`artifacts` contains all the test artifacts pertaining to the TCK: The TCK test classes and source, the TCK SPI classes and source, the TestNG suite.xml file and the SigTest signature files.

`doc` contains the documentation for the TCK (this reference guide)

`lib` contains the necessary prereqs for the TCK

`build.xml` is an ant build file which is used to run (and optionally build from source) the TCK.

`batch-tck.properties` is the properties file where required properties for the TCK are specified.

(And the remaining text files are self-explanatory.)

===	TCK test classes
The TCK test methods are contained in a number of test classes in the `com.ibm.jbatch.tck.tests` package.	Each test method is flagged as a TestNG test using the `@org.testng.annotations.Test` annotation.
 
===TCK test artifacts
Besides the test classes themselves, the Jakarta Batch TCK is comprised of a number of test artifact classes located in the `com.ibm.jbatch.tck.artifacts` package. These are the batch artifacts that have been implemented based on the Jakarta Batch API, and which are used by the individual test methods. The final set of test artifacts is the set of test JSL (XML) files, which are packaged in the `META-INF/batch-jobs` directory within `artifacts/com.ibm.jbatch.tck-1.0.2.jar`

The basic test flow simply involves a TestNG test method using the JobOperator API to start (and possibly restart) one or more job instances of jobs defined via one of the test JSLs, making use of some number of `com.ibm.jbatch.tck.artifacts` Java artifacts. The JobOperator is wrapped by a thin layer which blocks waiting for the job to finish executing (more on this in the discussion of the *porting package SPI* later in the document).

==	Configuration

===	TCK Properties
In order to run the TCK, you must define a property pointing to the Jakarta Batch runtime implementation that you are running the TCK against.

You will need to set one required property prior to running the Jakarta Batch TCK. This property is defined in the batch-tck.properties as follows:

Property = Required/Example Value	Description
batch.impl.classes=$HOME/foo/lib/ classes:$HOME/foo/lib/foo.jar:
$HOME/foo/lib/batch-api.jar	Path listing of the Jakarta Batch runtime implementation (that you are running the TCK against)

An optional property with name jvm.options is provided to specify JVM arguments using the TestNG <jvmarg line=""/> function:	This property should list the JVM arguments, separated by spaces.

Finally, some of the TCK tests sleep for a short period of time to allow an operation to complete or to force a timeout. These time values are defaulted via properties that are also specified in jsr352-tck.properties. These values can be adjusted if timing issues are seen in the implementation being tested. Refer to the documentation for a specific test (i.e. the comments in the test source) as to how the time value is used for that test.

5.2	Porting Package SPI
The Batch Applications for the Java Platform (Jakarta Batch) TCK relies on an implementation of a “porting package” SPI to function, in order to verify test execution results. The reason is that the JSR 352 specification API alone does not provide a convenient-enough mechanism to check results.
 
A default, “polling” implementation of this SPI is shipped within the TCK itself. The expectation is that the typical JSR 352 implementation will be content to use the TCK- provided, default implementation of the porting package SPI.

Further detail on the porting package is provided later in this document, in case you wish to provide your own, different implementation.


5.3	Configuring TestNG to run the TCK
TestNG is responsible for selecting the tests to execute, the order of execution, and reporting the results. Detailed TestNG documentation can be found at testng.org [http://testng.org/doc/documentation-main.html].

The artifacts/jsr352-tck-impl-suite.xml artifact provided in the TCK distribution must be run by TestNG 6.9 (described by the TestNG documentation as "with a testng.xml file") unmodified for an implementation to pass the TCK. This file also allows tests to be excluded from a run (for, say, debugging purposes).

6.	Executing Signature Tests

One of the requirements of an implementation passing the TCK is for it to pass the signature test. This section describes how to run the signature test against your implementation.

6.1	Obtaining the Signature Test Tool (and prerequisites)
You can obtain the Sigtest tool from the Sigtest home page at http://sigtest.java.net

The other prereq needed for the signature test is an implementation of class javax.enterprise.util.Nonbinding. This is, (at the time of this writing anyway), available for download as part of the CDI API, via Maven and other download mechanisms, among other possible options.

(We don't count the javax.inject.* package as a “prereq” here because, although it's a dependency, it is packaged along with our TCK).

6.2	JDK/JRE prerequisite

The signature test files to compare your implementation against were created with Oracle JDKs. The tests will not pass when run with the levels of IBM JDK/JRE available at the time of this writing. An Oracle JDK/JRE should probably be used, then, when running the signature tests.

To summarize: for each of Java 6 and Java 7, both the 'java' executable and the 'lib/rt.jar' referenced in the sample “running the signature tests” commands below should be part of a single Oracle JDK/JRE (a different one for each of Java 6 and Java 7, of course).
 
6.3	Running the Signature Tests
The TCK package contains the files jsr352-api-sigtest-java7.sig and jsr352- api-sigtest-java6.sig (in the artifacts directory).

Run the signature test by executing a command like the following:

java -jar $SIGTEST_DEV_JAR SignatureTest -static -package javax.batch
-filename jsr352-api-sigtest-java7.sig -classpath
$JAVA_HOME/lib/rt.jar:$JAVAX_INJECT_JAR:$JAVAX_ENTERPRISE_UTIL_JAR:
$MY_BATCH_API_JAR


Note the four dependencies here (not counting the JDK/JRE itself), the locations of which you may need to modify:

•	SIGTEST_DEV_JAR:	the location of 'sigtestdev.jar' from your Sigtest download.
•	JAVAX_INJECT_JAR:	(for class javax.inject.Qualifier, shipped with TCK)
•	JAVAX_ENTERPRISE_UTIL_JAR: (for class javax.enterprise.util.Nonbinding, not shipped with TCK)
•	MY_BATCH_API_JAR: Your own API JAR from your own implementation, which you are running the signature test against.

Here is an example showing a sample set of values for the shell variables used in the shorthand above, when running the signature test against the JSR 352 Reference Implementation.

It assumes:
1)	You have unzipped both RI and TCK into the same top-level directory.
2)	You are executing from working directory .../jsr352-tck-1.0
3)	You have already copied sigtestdev.jar into this directory
4)	You have already copied cdi-api-1.0.jar into this directory (this JAR contains the
javax.enterprise.util.Nonbinding class)
5)	Your 'java' executable and your 'rt.jar' come from a Java 7 JDK/JRE, since in the example you are running against the Java 7 signature file (based on the -filename argument)


java -jar sigtestdev.jar SignatureTest -static -package javax.batch
-filename artifacts/jsr352-api-sigtest-java7.sig -classpath
$JAVA_HOME/lib/rt.jar:lib/javax.inject.jar:../jsr352-ri- 1.0/javax.batch.api.jar:cdi-api-1.0.jar

Again, be sure to choose the correct version of the signature file depending on your the Java version (6 or 7) of your JDK/JRE.
 
6.4	Determining success

The output of your execution should include, at the very end:

STATUS:Passed
Again, in order to pass the JSR352 TCK you have to make sure that your API passes the signature tests.

6.5	Forcing a Signature Test failure (optional)
For additional confirmation that the signature test is working correctly, a failure can be forced by doing the following:

•	Edit jsr352-api-sigtest-java7.sig
•	Modify one of the class signatures. For example, change this:
CLSS public abstract interface javax.batch.api.chunk.CheckpointAlgorithm
meth public abstract boolean isReadyToCheckpoint() throws java.lang.Exception
meth public abstract int checkpointTimeout() throws java.lang.Exception
meth public abstract void beginCheckpoint() throws java.lang.Exception
meth public abstract void endCheckpoint() throws java.lang.Exception

to the following:

(changing the isReadyToCheckpoint method to accept a java.lang.String
parameter)

CLSS public abstract interface javax.batch.api.chunk.CheckpointAlgorithm
meth public abstract boolean isReadyToCheckpoint(java.lang.String) throws java.lang.Exception
meth public abstract int checkpointTimeout() throws java.lang.Exception
meth public abstract void beginCheckpoint() throws java.lang.Exception
meth public abstract void endCheckpoint() throws java.lang.Exception

When the signature test is then run, it will fail with the following error:

Missing Methods
---------------
javax.batch.api.chunk.CheckpointAlgorithm:	method
 
public abstract boolean javax.batch.api.chunk.CheckpointAlgorithm.isReadyToCheckpoint(java.la ng.String) throws java.lang.Exception

Added Methods
-------------
javax.batch.api.chunk.CheckpointAlgorithm:	method public abstract boolean javax.batch.api.chunk.CheckpointAlgorithm.isReadyToCheckpoint() throw s java.lang.Exception

duplicate messages suppressed: 1 STATUS:Failed.3 errors
6.6	Creating the Signature File (optional, for reference)
Though the requirement for passing the TCK is to run the signature test against the exact copies of the “.sig” files shipped within the TCK, it can be helpful for debugging to understand how those files were generated.

The “.sig” files were created using a command like the following:


java -jar sigtestdev.jar Setup -static -package javax.batch -filename jsr352-api-sigtest-java7.sig -classpath
$JAVA_HOME/lib/rt.jar:lib/javax.inject.jar:../jsr352-ri- 1.0/javax.batch.api.jar:cdi-api-1.0.jar

This example assumes you are executing from the jsr352-tck-1.0 directory, similar to the “run” command example in Section 5.3. Modify the path as needed in a similar manner.

Also note that the Java version of the 'java' executable in the above command determines what Java version the signature file will correspond to. In this example, we use a filename of jsr352-api-sigtest-java7.sig' to show that this a Java 7 executable (assumed for this example).


7.	Executing TestNG Test Suite

The build.xml file is used for running the test suite in standalone mode with ant.
The default target, run, will invoke TestNG, running the tests specified in the suite xml file at
artifacts/jsr352-tck-impl-suite.xml (described
by the TestNG documentation as "with a testng.xml file"). A report will be generated by TestNG in the results directory.
 
The list of test cases to run can be customized by modifying the the TestNG suite xml file at artifacts/jsr352-tck-impl-suite.xml. (Note that an implementation must run against that provided suite.xml file as-is, to pass the TCK.

7.1	Timeouts
The JobOperatorBridge makes use of the following system property:

tck.execution.waiter.timeout

with a default value of 900000 (900 seconds). The intention here is that the test should not wait forever if something catastrophic occurs causing the job to never complete (or if the porting package SPI “waiter” is never notified for some reason). The test also can't end too soon, causing a test failure because the wait was not long enough.

This timeout value can be customized (say, to increase when debugging or decrease to force a faster failure in some cases).

Note that some of the tests (e.g. the chunk tests involving time-based checkpointing) will take at least 15-25 seconds to run on any hardware, so any value less than that for the whole TCK will cause some test failures simply due to timing (and not because of any failure in the underlying JSR 352 implementation).

The 900 seconds value, then, was chosen to avoid falsely reporting an error because of timing out too soon, allowing plenty of leeway.	It also facilitates debugging.	It does not, however, provide “fast failure” in case of a hang or runaway thread.

7.2	Building the TCK (optional, for reference):
The TCK tests can be optionally built from source. However, note that for an implementation to pass the TCK, it must run against the shipped TCK test suite binary as-is (and not against a modified TCK). Still it may be convenient to be able to build the TCK from source for debugging purposes.

The TCK source is included with the TCK zip, and can be located in jsr352-tck-impl- src.jar. Extract this archive to a directory, and note that location. Modify the “tck-src” property to point to the directory to which you've extracted the source. The “compile” target can then be used to build the TCK from source, with the resulting class files being located in the “build” directory.
